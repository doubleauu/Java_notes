- 基数和权值
- 二进制转换为十进制使用 **按权展开求和**
- 十进制转换为二进制使用 **除二取余，逆序排列**
---
我们来系统地讲解一下计算机中常用的几种进制、它们之间的转换方法以及最重要的——**转换的底层原理**。

理解了原理，你就不再需要死记硬背各种转换规则了。

---

### 一、核心原理：什么是进制？

所有进制的本质都是同一个思想：**“逢N进一”**。

*   我们最熟悉的**十进制（Decimal）**，就是“逢十进一”。它由 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 这十个数字组成。当数到 9 再加 1 时，个位无法表示了，就向十位进 1，个位归 0，变成了 10。
*   这个 “N” 就是**基数（Base）**。十进制的基数是 10。

另一个核心概念是 **“位权”（Weight）**。一个数字在不同位置上代表的值是不同的。

比如十进制数 `327`，我们下意识就知道它是：
`3 × 10² + 2 × 10¹ + 7 × 10⁰`
= `3 × 100 + 2 × 10 + 7 × 1`
= `300 + 20 + 7`
= `327`

这里的 `10²`, `10¹`, `10⁰` 就是每一位的**位权**。这个 “按权展开” 的思想是所有进制转换的基石。

---

### 二、计算机中常用的进制

| 进制              | 中文名  | 基数 (Base) | 组成数字                                          | 应用场景                  |
| :-------------- | :--- | :-------- | :-------------------------------------------- | :-------------------- |
| **Binary**      | 二进制  | 2         | 0, 1                                          | 计算机底层硬件（高低电平）         |
| **Octal**       | 八进制  | 8         | 0, 1, 2, 3, 4, 5, 6, 7                        | 早期计算机系统（现在较少用）        |
| **Decimal**     | 十进制  | 10        | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9                  | 人类日常使用                |
| **Hexadecimal** | 十六进制 | 16        | 0-9, A(10), B(11), C(12), D(13), E(14), F(15) | 程序员常用，表示**内存地址**、颜色值等 |

**为什么程序员喜欢用十六进制？**
因为计算机底层是二进制，但二进制写起来太长了（例如 `10110101`）。而十六进制与二进制有完美的对应关系（**1位十六进制数正好等于==4位==二进制数**），可以非常方便、紧凑地表示二进制数据，是二进制的完美“缩写”。

---

### 三、进制转换原理与方法

#### 1. 其他进制 转换到 十进制

**原理**：**按权展开求和 (Positional Notation)**
将每一位的数字乘以其对应的位权，然后全部相加。<!--更符合十进制的加法规则-->

*   **示例1：二进制转十进制**
    转换二进制数 `1101.1`
    ```
    1    1    0    1   .   1   (二进制)
    |    |    |    |       |
    2³   2²   2¹   2⁰      2⁻¹ (位权)

    = (1 × 2³) + (1 × 2²) + (0 × 2¹) + (1 × 2⁰) + (1 × 2⁻¹)
    = (1 × 8)  + (1 × 4)  + (0 × 2)  + (1 × 1)  + (1 × 0.5)
    = 8 + 4 + 0 + 1 + 0.5
    = 13.5 (十进制)
    ```

*   **示例2：十六进制转十进制**
    转换十六进制数 `2AF`
    ```
    2    A    F     (十六进制)
    |    |    |
    16²  16¹  16⁰   (位权)
    (A代表10, F代表15)

    = (2 × 16²) + (10 × 16¹) + (15 × 16⁰)
    = (2 × 256) + (10 × 16)  + (15 × 1)
    = 512 + 160 + 15
    = 687 (十进制)
    ```

#### 2. 十进制 转换到 其他进制<!--刚好是按权展开的逆向，结合十进制的加法规则-->

**原理**：**除N取余，逆序排列 (Division-Remainder Method)**
对整数部分，用目标进制的基数 N 去除，记录余数，直到商为0。然后将所有余数倒序排列。

*   **示例：十进制转二进制**
    转换十进制数 `26`
    ```
      26 ÷ 2 = 13 ... 余 0  (最低位)
      13 ÷ 2 = 6  ... 余 1
       6 ÷ 2 = 3  ... 余 0
       3 ÷ 2 = 1  ... 余 1
       1 ÷ 2 = 0  ... 余 1  (最高位)
    ```
    将余数**从下往上**倒序排列，得到：`11010`。
    所以，十进制 `26` 等于二进制 `11010`。

*   **示例：十进制转十六进制**
    转换十进制数 `687`
    ```
      687 ÷ 16 = 42 ... 余 15 (F) (最低位)
       42 ÷ 16 = 2  ... 余 10 (A)
        2 ÷ 16 = 0  ... 余 2   (最高位)
    ```
    将余数**从下往上**倒序排列，得到：`2AF`。
    所以，十进制 `687` 等于十六进制 `2AF`。

> **小数部分转换**：乘以N，取整数部分，顺序排列。这里不展开，整数部分转换更常用。

#### 3. ==二进制 与 十六进制/八进制 的快速转换==（重点！）

这是程序员必须掌握的技巧，因为它利用了基数之间的整数次幂关系 (**`8=2³`, `16=2⁴`**)。

**原理**：**分组转换**

*   **二进制 转 十六进制**
    **规则**：从小数点开始，向左（整数部分）和向右（小数部分）每 **4** 位为一组，不足4位的用0补齐。然后将每组独立转换成对应的十六进制数。

    **示例**：转换二进制 `110101110.011`
    ```
    // 整数部分分组 (从右向左)
    0001  1010  1110
      ↓     ↓     ↓
      1     A     E

    // 小数部分分组 (从左向右)
    .0110
       ↓
       6
    ```
    组合起来就是 `1AE.6`。

*   **十六进制 转 二进制**
    **规则**：将每一位十六进制数独立地转换成 **4** 位二进制数，不足4位的在左边补0。

    **示例**：转换十六进制 `5D.C`
    ```
      5     D   .   C
      ↓     ↓       ↓
    0101  1101  .  1100
    ```
    组合起来就是 `01011101.1100`（前面的0可以省略）。

*   **二进制与八进制的转换**
    规则完全相同，只是分组的位数变成了 **3** 位。
    *   `二进制 -> 八进制`: 每3位一组。
    *   `八进制 -> 二进制`: 每1位转3位。

---

### 四、总结

1.  **核心原理**：“逢N进一” 和 “按权展开”。
2.  **转十进制**：统一使用 “按权展开求和” 法。
3.  **十进制转**：统一使用 “除N取余，逆序排列” 法。
4.  **二、八、十六进制互转**：利用分组法，这是最快的技巧。**（1位十六进制 <=> 4位二进制；1位八进制 <=> 3位二进制）**

掌握了这些原理和核心方法，任何进制之间的转换对你来说都会变得非常清晰。