好的，这是一个非常好的问题。在Java中，虽然没有像C++ `typeid` 那样直接的运算符，但通过Java强大的**反射 (Reflection)** 机制，我们可以很容易地在运行时获取任何对象的类型信息。

主要有以下几种方法：

---

### 1. 使用 `Object.getClass()` 方法 (最常用)

所有Java对象都继承自 `Object` 类，而 `Object` 类提供了一个 `getClass()` 方法，该方法返回一个 `Class` 类的实例，这个实例就代表了该对象的运行时类型。

`Class` 对象本身包含了类的所有元数据（metadata），例如类名、方法、字段等。

**示例代码：**

```java
import java.util.ArrayList;

public class PrintTypeExample {
    public static void main(String[] args) {
        // 1. 对于标准库中的对象
        String myString = "Hello, Java!";
        ArrayList<Integer> myList = new ArrayList<>();

        // 使用 getClass() 获取 Class 对象，然后用 getName() 获取全限定类名
        System.out.println("myString 的类型是: " + myString.getClass().getName());
        // 输出: myString 的类型是: java.lang.String

        System.out.println("myList 的类型是: " + myList.getClass().getName());
        // 输出: myList 的类型是: java.util.ArrayList

        // 2. 对于自定义对象
        Dog myDog = new Dog();
        System.out.println("myDog 的类型是: " + myDog.getClass().getName());
        // 输出: myDog 的类型是: Dog (如果Dog类在默认包下)
        // 如果在 com.example 包下，则输出 com.example.Dog

        // 如果只想看简单的类名，而不是完整的包路径
        System.out.println("myDog 的简单类型名是: " + myDog.getClass().getSimpleName());
        // 输出: myDog 的简单类型名是: Dog
    }
}

class Dog {
    // 一个简单的自定义类
}
```

### 2. 对于基本数据类型 (Primitive Types)

基本数据类型（如 `int`, `double`, `char` 等）不是对象，所以它们**没有 `getClass()` 方法**。但是，你可以通过它们的包装类或者使用 `.class` 语法来获取它们的类型信息。

**示例代码：**

```java
public class PrimitiveTypeExample {
    public static void main(String[] args) {
        int myInt = 10;
        double myDouble = 3.14;

        // 错误的做法，无法编译
        // System.out.println(myInt.getClass().getName());

        // 正确的做法 1: 使用 .class 语法
        Class<Integer> intType = int.class;
        Class<Double> doubleType = double.class;
        System.out.println("int 的类型是: " + intType.getName());
        // 输出: int 的类型是: int

        System.out.println("double 的类型是: " + doubleType.getName());
        // 输出: double 的类型是: double

        // 正确的做法 2: 通过其包装类 (Wrapper Class)
        Integer myInteger = myInt; // 自动装箱 (Autoboxing)
        System.out.println("myInteger 的类型是: " + myInteger.getClass().getName());
        // 输出: myInteger 的类型是: java.lang.Integer
    }
}
```

### 3. 使用 `instanceof` 运算符进行类型检查

如果你不是想打印出类型的名字，而是想**判断一个对象是否是某个特定类型（或其子类型）的实例**，你应该使用 `instanceof` 运算符。这在功能上更接近C++中 `dynamic_cast` 成功与否的判断。

**示例代码：**

```java
public class InstanceOfExample {
    public static void main(String[] args) {
        Object obj = "I am a String";

        if (obj instanceof String) {
            System.out.println("obj 是一个 String 类型的实例");
            // 在这个代码块中，你可以安全地将 obj 强制转换为 String
            String str = (String) obj;
            System.out.println("转换成功: " + str.toUpperCase());
        }

        if (obj instanceof Integer) {
            System.out.println("obj 是一个 Integer 类型的实例");
        } else {
            System.out.println("obj 不是一个 Integer 类型的实例");
        }
    }
}
```

### 总结

| 需求 | Java实现方式 | 说明 |
| :--- | :--- | :--- |
| **获取对象的精确运行时类型名** | `obj.getClass().getName()` 或 `getSimpleName()` | 最常用，适用于所有非 `null` 的对象。 |
| **获取基本数据类型的类型信息** | `int.class`, `double.class` 等 | 使用 `.class` 语法直接获取。 |
| **判断对象是否为某类型或其子类的实例** | `obj instanceof TypeName` | 用于类型检查和安全的类型转换。 |

总的来说，`obj.getClass()` 是与C++ `typeid(*obj)` 最直接对应的功能，用于获取一个对象在运行时的确切类型。